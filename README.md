# UltraHonk zk-SNARK Verifier

The UltraHonk zk-SNARK verifier is a Rust-based implementation of Noir's UltraHonk Solidity verifier, optimized to be used contextually with [zkVerify](https://github.com/zkVerify/zkVerify).

## Usage

Below, we present a basic use case of verifying an UltraHonk zk-SNARK proof using our implementation:

```rust
extern crate alloc;

use alloc::boxed::Box;
use ultrahonk_no_std::{ProofType, verify};

// Sample zero-knowledge proof, vk, and public inputs
let zk_proof_data = Box::from(include_bytes!(".././tests/data/zk_proof").as_slice());
let vk: &[u8] = include_bytes!(".././tests/data/vk");
let pubs: Vec<[u8; 32]> = include_bytes!(".././tests/data/pubs")
    .chunks_exact(32)
    .map(|c| c.try_into().unwrap())
    .collect();

// Use the `ProofType::ZK` variant to wrap around `zk_proof_data`.
let proof: ProofType = ProofType::ZK(zk_proof_data);

// Call the UltraHonk verifier.
assert!(verify::<()>(vk, &proof, &pubs).is_ok()); // success
```

> **Note:** Please note that this verifier currently only supports the following configuration:
- **ZK vs Plain:** Noir is able to generate "plain" proofs where there is no guarantee for witness privacy, as well as zero-knowledge (ZK) proofs for a given circuit. Our verifier is compatible with *both* types of proofs,
- **Transcript generation:** Keccak256 is used as the hash function,
- **Recursive proofs:** currently not supported.

> When working with a plain proof, wrap its bytes in the `ProofType::Plain` variant, like so: `let proof: ProofType = ProofType::Plain(Box::new(plain_proof_data));`

## Generate an UltraHonk proof with Noir toolchain

Please, ensure that you are using the latest version of Noir and follow the [official Noir documentation](https://noir-lang.org/docs/getting_started/quick_start) to generate a sample proof. At the end of the process you should have four binary files generated by `bb`, namely, the `proof`, `vk`, `public_inputs`, and `vk_hash`.

Please make sure to use `-s ultra_honk` in order to make explicit that you wish to use UltraHonk as your proving scheme. In addition, use `--oracle_hash keccak` to instruct `bb` to generate a proof with `keccak` as the hash function. Optionally, use `--disable_zk` to specify that you would like `bb` to use the non zero-knowledge (plain) version of UltraHonk for proof generation (omit if you wish to obtain a ZK proof). Finally, add the the `write_vk` subcommand to instruct `bb` to also generate the verification key for you.

> **Example:** Here's a worked example:
- `bb prove -s ultra_honk --oracle_hash keccak --write_vk -b ./target/hello_world.json -w ./target/hello_world.gz -o ./target`

## Convert `proof`, `vk`, and `pubs` into zkVerify-compatible format
The binary files output by Noir are ready to use out of the box. However, for your ease of submission to `zkVerify`, below we provide a Bash script for converting them into hexadecimal files `zkv_proof.hex`, `zkv_vk.hex`, and `zkv_pubs.hex`.

Please run the following script, adjusting the path to the proof, vk, and public inputs files, accordingly:

```bash
#!/usr/bin/env bash

PROOF_TYPE="ZK"                # Set to "Plain" if you are using the non-zk variant of UltraHonk
ARTIFACT_DIR_PATH="./target"   # Adjust path depending on where the Noir-generated artifacts are
OUTPUT_DIR_PATH="./target"     # Adjust path based on where you would like the zkv-ready artifacts to be placed

# You may ignore these:
PROOF_FILE_PATH="${ARTIFACT_DIR_PATH}/proof"
VK_FILE_PATH="${ARTIFACT_DIR_PATH}/vk"
PUBS_FILE_PATH="${ARTIFACT_DIR_PATH}/public_inputs"
ZKV_PROOF_HEX_FILE_PATH="${OUTPUT_DIR_PATH}/zkv_proof.hex"
ZKV_VK_HEX_FILE_PATH="${OUTPUT_DIR_PATH}/zkv_vk.hex"
ZKV_PUBS_HEX_FILE_PATH="${OUTPUT_DIR_PATH}/zkv_pubs.hex"

# Convert proof to hexadecimal format
{
  if [ -f "$PROOF_FILE_PATH" ]; then
    PROOF_BYTES=$(xxd -p -c 256 "$PROOF_FILE_PATH" | tr -d '\n')
    printf '`{\n    "%s:" "0x%s"\n}`\n' "$PROOF_TYPE" "$PROOF_BYTES" > "$ZKV_PROOF_HEX_FILE_PATH"
    echo "✅ 'proof' hex file generated at ${ZKV_PROOF_HEX_FILE_PATH}."
  else
    echo "❌ Error: Proof file '$PROOF_FILE_PATH' not found. Skipping." >&2
  fi
}

# Convert vk to hexadecimal format
{
  if [ -f "$VK_FILE_PATH" ]; then
    printf "\"0x%s\"\n" "$(xxd -p -c 0 "$VK_FILE_PATH")" > "$ZKV_VK_HEX_FILE_PATH"
    echo "✅ 'vk' hex file generated at ${ZKV_VK_HEX_FILE_PATH}."
  else
    echo "❌ Error: Verification key file '$VK_FILE_PATH' not found. Skipping." >&2
  fi
}

# Convert public inputs to hexadecimal format
{
  if [ -f "$PUBS_FILE_PATH" ]; then
    xxd -p -c 32 "$PUBS_FILE_PATH" | sed 's/.*/"0x&"/' | paste -sd, - | sed 's/.*/[&]/' > "$ZKV_PUBS_HEX_FILE_PATH"
    echo "✅ 'pubs' hex file generated at ${ZKV_PUBS_HEX_FILE_PATH}."
  else
    echo "❌ Error: Public inputs file '$PUBS_FILE_PATH' not found. Skipping." >&2
  fi
}
```

And with that, you're all set!